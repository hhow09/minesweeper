# Minesweeper

Implement the classic Windows game Minesweeper with React.

[Live Demo](https://hhow09.github.io/minesweeper/)

## Rules

1. Clicking a mine ends the game.
2. Clicking a square with an adjacent mine clears that square and shows the number of mines touching it.
3. Clicking a square with no adjacent mine clears that square and clicks all adjacent squares.
4. The first click will never be a mine.
5. It will clear the map and place numbers on the grid.
6. The numbers reflect the number of mines touching a square.

## How to Play

0. Open [Live Demo](https://hhow09.github.io/minesweeper/)
1. Adjust Board Config
2. Click `Start`
3. `Left Click` to open a cell
4. `Right Click` to flag a cell (suspicious mine)

## Documentation

### 1. Config

- Board Width: how many columns of a board
- Board Height: how many rows of a board
- Bomb Probability: the probability of whether a cell is a mine
- Show Log: show the log of function execution in Devtool console panel

### 2. Prepare Board

![prepare Board](https://github.com/hhow09/minesweeper/blob/master/flowchart/prepare-board.png?raw=true)

#### Create Board Matrix

generate 2D array of board state based on `Board Width` and `Board Height`. Each element contains a least basic properties of a cell: `opened`, `isBomb`, `adjBombNum` and `flagged`.

#### Place Bombs

iterate through every cell of board state and performs following actions respectively.

1. randomly set `isBomb` to `true` based on `Bomb Probability`.
2. if set bomb, update `adjBombNum` of adjacent cells.

### 3. Click A Cell

![Click A Cell](https://github.com/hhow09/minesweeper/blob/master/flowchart/click-a-cell.png?raw=true)

#### Right Click

Flag / Unflag a cell

#### Left Click

- Performs `setState` only once.
- The corresponding new state is generated by pipeline of pure function: `handleFirstBomb`, `openCell`, `openAdjacentSafeCells`, `openBomb`, `doSideEffect`, `getState` in [helper.js](https://github.com/hhow09/minesweeper/blob/master/src/helper.js).
  - handleFirstBomb: Given a boardState and cell location, modify the cell to normal cell and update adjBombNum of adjacent cells.
  - openAdjacentSafeCells: Given a boardState and cell location, Using Depth-First-Search get all adjacent cells of `adjBombNum===0`, then set these cell state `opened=true`. The problem is similar to [Leetcode 200. Number of Islands](https://leetcode.com/problems/number-of-islands/)
  - openCell: Given a boardState and cell location, set the given cell state `opened=true`
  - openBomb: Given a boardState and cell location, set the given cell state `opened=true` & `background="red"`
  - doSideEffect: Use the information of previous function, do something then return as input. Here use to get count of openAdjacentSafeCells.
  - getState: return boardState

##### Condition: First Click && is mine && adjacentMines==0

![First Click && is mine && adjacentMines==0](https://github.com/hhow09/minesweeper/blob/master/flowchart/detail-first-click-bomb-adj0.png?raw=true)

##### Condition: First Click && is mine && adjacentMines>0

![First Click && is mine && adjacentMines>0](https://github.com/hhow09/minesweeper/blob/master/flowchart/detail-first-click-bomb-adj1.png?raw=true)

##### Condition: Normal cell && adjacentMines==0

![Normal cell && adjacentMines==0](https://github.com/hhow09/minesweeper/blob/master/flowchart/detail-normal-adj0.png?raw=true)

##### Condition: Normal cell && adjacentMines>0

![Normal cell && adjacentMines>0](https://github.com/hhow09/minesweeper/blob/master/flowchart/detail-normal-adj1.png?raw=true)

##### Condition: Not first Click && is mine

![Not first Click && is mine](https://github.com/hhow09/minesweeper/blob/master/flowchart/click-bomb.png?raw=true)

### 4. Check Board Status

![check board status](https://github.com/hhow09/minesweeper/blob/master/flowchart/check-board-status.png?raw=true)

## Designs I have tried

I have tried several ways of `handleClickCell` for updating `boardState` (list in chronological order)

1. Multiple steps of setState

   The first and naive design is performing multiple steps of `setState` (ex. handleFirstBomb, openAdjacentSafeCells...) inside `handleClickCell` function. `It did not worked` because each step relies on the result of previous step and the fact that `setState` of React does not work synchronously.

2. Single setState with pipeline of pure functions

   Instead of multiple `setState`, I refactored `handleClickCell` into single setState function with pipeline of pure functions executed inside updater function of setState. `It worked`. All functions are listed in `helper.js`.

3. State management with useReducer

   Re-render of each cell happens `whenever boardState change` even for the unchanged cells because of the native characteristics of React functional component. Problem of unnecessary re-render becomes significant when scaling up board size. The goal here is to memoize the props of unchanged `Cell`.

   The primitive type of props (ex. `isBomb`: boolean, `adjBombNum`: number) can be directly compare using equal operator. The trickiest of the problem is `handleClickCell`, function is an Object in javascript, depends on boardState directly which leads to the recreation itself whenever boardState change.

   > `dispatch` won't change between re-renders ([reference](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down))

   In order to remove the dependency of boardState inside `handleClickCell`. I replaced the `useState` with `useReducer` and perform state change inside reducer. In that way the `handleClickCell` will only depend on static `dispatch` and `actions`. Then I can easily memorize the same reference of it with `useCallback` hook and wrap `Cell` with HOC `React.memo` for preventing unnecessary re-render.

## Limitation When scaling up Board

1. Recursion and Maximum call stack exceed

   When `bombProbability` is low (ex.0.01) , e.g. lots of safe cells, the recursive method of `findAdjacentSafeCells` is prone to `Maximum call stack size exceeded error`. Common technique to prevent recursion from call stack size exceed is to push recursion into macro task using `setTimeout`. Since it is called inside setState, which should be synchronous and pure, `setTimeout` does not work here.

2. Slow render

   Even If I managed to prevent unnecessary re-render of cell with useCallback, memo and useReducer. It still take long to do reconciliation process.
